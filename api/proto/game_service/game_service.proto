syntax = "proto3";
package game_service;
option go_package = "github.com/domino14/liwords/rpc/api/proto/game_service";

import "ipc/omgwords.proto";
import "macondo/macondo.proto";

// Meta information about a game, including its players.
message GameInfoRequest { string game_id = 1; }

message GCGRequest { string game_id = 1; }
message GameHistoryRequest { string game_id = 1; }
message GameDocumentRequest { string game_id = 1; }

message GCGResponse { string gcg = 1; }
message GameHistoryResponse { macondo.GameHistory history = 1; }
message GameDocumentResponse { ipc.GameDocument document = 1; }

message RecentGamesRequest {
  string username = 1;
  int32 num_games = 2;
  int32 offset = 3;
}

message StreakInfoResponse {
  message SingleGameInfo {
    string game_id = 1;
    int32 winner = 3; // the index in `players` or -1 if no winner (tie)
  }

  message PlayerInfo {
    string nickname = 1;
    string uuid = 2; // player uuid needed for censoring
  }
  repeated SingleGameInfo streak = 1;
  repeated PlayerInfo playersInfo = 3;
}

message RematchStreakRequest { string original_request_id = 1; }

service GameMetadataService {
  rpc GetMetadata(GameInfoRequest) returns (ipc.GameInfoResponse);
  // GetGCG gets a GCG string for the given game ID.
  rpc GetGCG(GCGRequest) returns (GCGResponse);
  // GetGameHistory gets a GameHistory for the given game ID. GameHistory
  // is our internal representation of a game's state.
  rpc GetGameHistory(GameHistoryRequest) returns (GameHistoryResponse);
  // GetRecentGames gets recent games for a user.
  rpc GetRecentGames(RecentGamesRequest) returns (ipc.GameInfoResponses);
  rpc GetRematchStreak(RematchStreakRequest) returns (StreakInfoResponse);
  // GetGameDocument gets a Game Document. This will eventually obsolete
  // GetGameHistory.
  rpc GetGameDocument(GameDocumentRequest) returns (GameDocumentResponse);
}

// GameEventResponse doesn't need to have any extra data. The GameEvent API
// will still use sockets to broadcast game information.
message GameEventResponse {}

message TimePenaltyEvent { int32 points_lost = 1; }
message ChallengeBonusPointsEvent { int32 points_gained = 1; }
message CreateBroadcastGameRequest {
  // metadata

  // PlayerInfo for broadcast games do not need to be tied to a Woogles
  // UUID. These games are meant for sandbox/annotation/broadcast of
  // a typically IRL game.
  message PlayerInfo {
    string nickname = 1;
    string real_name = 2;
  }

  repeated PlayerInfo playersInfo = 1;
  string lexicon = 2;
  ipc.GameRules rules = 3;
  macondo.ChallengeRule challenge_rule = 4;
  // public will make this game public upon creation - i.e., findable
  // within the interface. Otherwise, a game ID is required.
  bool public = 5;
}

message CreateBroadcastGameResponse { string game_id = 1; }

message BroadcastGamePrivacy { bool public = 1; }

// GameEventService will handle our game event API. We can connect bots to this
// API, or use it for sandbox mode, or for live annotations, etc.
service GameEventService {
  // CreateBroadcastGame will create a game for Woogles broadcast
  rpc CreateBroadcastGame(CreateBroadcastGameRequest)
      returns (CreateBroadcastGameResponse);
  rpc SendGameEvent(ipc.ClientGameplayEvent) returns (GameEventResponse);
  // SendTimePenaltyEvent sends a time penalty event. It should be the
  // last event right before a game ends.
  rpc SendTimePenaltyEvent(TimePenaltyEvent) returns (GameEventResponse);
  // SendChallengeBonusEvent sends a bonus points event. When challenging
  // a play that is good, depending on the challenge rule a certain number
  // of points may be added to the play. Since broadcast games can reflect
  // real-life games, the number of points can be variable (for example,
  // 15 points for 5-pt challenge if 3 plays are challenged)
  rpc SendChallengeBonusEvent(ChallengeBonusPointsEvent)
      returns (GameEventResponse);

  rpc SetBroadcastGamePrivacy(BroadcastGamePrivacy) returns (GameEventResponse);
}